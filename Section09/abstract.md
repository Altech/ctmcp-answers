# 関係プログラミング
第一部：一般的計算モデルの最終章。この章では、これまで扱ってきた宣言的モデルの関数（一章〜四章など）という見方を一般化して関係に基づいた計算モデルを考える。

## 関係の上でプログラムすること
プログラマの視点で考えよう。核言語に以下のような文を追加する。

	choise <s1> [] ... [] <sn> end % 選択
	fail % 失敗

choise文は、文`<s1>`...`<sn>`の中からどれか一つを選択し、実行する。その実行において`1=2`といった失敗（fail）があれば、改めて別の文`<si>`を選択する。こういう文によって、例えば次のような関数が書ける。

	fun {PrimaryColors} 
	  choice red [] blue [] green end 
	end

これは「呼び出し`{PrimaryColors}`の値は`red`または`blue`または`green`である」と解釈できる。PrimaryColorsは「関数」ではなく「関係」と見る。また、こういう性質を、決まった値を返していた宣言的モデルにおける関数と対比して、「非決定性である」と言う。このような非決定性選択があると、プログラムを論理的な表明のように書くことができる。例えば、

    fun {TwoPrimaryColors} X Y in
  	  X = {PrimaryColors}
	  Y = {PrimaryColors}
	  (X\=Y) = true
	  X#Y
	end

は、「Xは原色で、Yも原色で、XとYは異なる」という意味に取れ、`red#blue`のような解を返す。実装が深さ優先探索だとして、実行は次のようになるだろう。

1. Xにredが束縛される（選択）
2. Yにredが束縛される（選択）
3. X\=Yでfalseとなり、false=trueが実行される（失敗）
4. 失敗したのでYの選択をやり直しYにblueが束縛される（選択）
5. X\=Yでtrueとなるので失敗せず、X#Yとしてred#blueが返る

これから分かるように、関係の上でプログラムを実行することは、実際には探索を行うことである。明らかに計算量は指数的になる。それを一般的に避けることはできない。このため、探索空間が小さいか、問題の構造を調べるための研究用のツールとして使う場合において実用的であり、それ以外の場合に適用するにはもっと手の込んだ技法が必要になる（十二章：制約プログラミング）。とりあえずこの章では実用的な場合に限って考える。

## 論理型プログラミングとの関係
宣言的プログラミングおよび関係プログラミングは、論理型プログラミングと密接な関係がある。論理型プログラムとは、「操作的意味が与えられた（つまり実行できる）論理の表明」である。論理型プログラムは操作的意味と論理的意味の両方を持つ。この論理的意味の基礎としては、一階述語論理（命題論理に変数、項、限定子を加えたもの）がある。一階述語論理に公理の集合を与えることで演繹が可能になる。

### 論理型プログラミング
論理型プログラムは、一階述語論理の公理の集合と、質問（query）、及び演繹を行うためのシステムである「定理証明器」から成る。論理型プログラムを実行するにあたって、次のようなことを考える必要がある。

- 真であってもその証明がその論理モデルの中では存在しないことがあるという、理論的な限界（不完全性定理）
- プログラマがアルゴリズムを定義できかつ計算量を予測できるという実用上の要求への対応
- 構成的（真の場合その具体例を出せる）である必要性

これらのことに対して、次のような二つの考え方がある。

- 形式を制限することで効率のよい定理証明器を作れるようにする
  - Prolog は公理をホーン節（`∀x1,...,xn. <a1>∧...∧<an> → <a>`という形）に限定して、推論規則として導出（resolution）を使う
- プログラマが実践的な知識を使って定理証明器を助けられるようにする
  - 例えばソートを行う論理型プログラムを書くことはできるが効率が悪い。そういう部分にマージソートを使えるようにする。論理的意味は変わらない。

### 論理的意味と操作的意味
関係プログラムの任意の文`<s>`を論理式`T(<s>)`に容易に翻訳することができる。例えば、`if X then <s1> else <s2> end`は`x=true ∧ T(<s1>) ∨ x=false ∧ T<s2>`である。

リストの連結（Append）を書いてみて、操作的意味と論理的意味の両方の立場で、プログラムの実行について考える。

#### 決定性連結
以下は宣言的モデルで書いたAppend関数である。

	fun {Append A B}
	  case A
	  of nil then B
	  [] X|As then X|{Append As B}
	end

手続きの形で書くと以下のようになる。

	proc {Append A B C}
	  case A
	  of nil then C=B
	  [] X|As then C=X|{Append As B}
	end

この論理的意味は、翻訳により`∀a,b,c. append(a,b,c) ⇔ (a=nil ∧ c=b) ∨ (∃x,a',b'. a=x|a' ∧ c=x|c' ∧ append(a',b,c'))`となる。これの実行は、論理的には`append([1,2,3],[4,5],x)`が演繹により`append([1,2,3],[4,5],[1,2,3,4,5])`となることである。

もう少し考えてみる。論理的意味に立てば、`append(a,b,c)`は(a,b,c)が連結関係である、ということを言っているので、`append(x,[4,5],[1,2,3,4,5])`が演繹により`append([1,2],[4,5],[1,2,3,4,5])`となることが期待されるが、上の関数はそうならない。引数Aが束縛されていることが前提となっていて（`case A`の部分で）ブロックするからである。宣言的モデルのAppendは（入力から出力への）方向性を持つため、それに対応していない演繹はできない。それでも、無限再帰やブロック、例外が起こらず実行がきちんと終了した時には論理的意味を守る。

#### 非決定性連結
上のAppend関数の論理的意味を満たすよう、今度はchoise文を使ってAppend関数を書くと以下のようになる。

	proc {Append ?A ?B ?C}
	  choise 
	    A=nil B=C
	  [] As Cs X in
	    A=X|As C=X|Cs {Append As B Cs}
	  end
	end

これは、例えば二つの引数が決まっていないような呼び出し`{Append X Y [1 2 3]}`でも`X#Y`が`nil#[1 2 3]`や`[1]#[2 3]`といった解を返す。まったく引数が決まっていないような呼び出しに対してすら解を返す（ただしそういう解は無限にあるので全て列挙することはできない）。

#### 決定性連結と非決定性連結、あるいは関数的手続きと関係的手続き
以上の例から分かることを次にまとめる。非決定性連結と違って決定性連結は方向性を持つため、入力として想定されたものを出力にしようとしたりしても、演繹されない。非決定性はそうではない。つまり、非決定性の手続きは部分的な情報に基づいて計算を行うことができる。そして、決定性連結（関数的手続き）と違い、非決定性連結（関係的手続き）は、ある引数を入力にするか出力にするかを呼び出しの度に決められる。ただし、こういった柔軟性の裏には指数的な探索や無限ループに陥る可能性がある。

非決定性の手続きはどうしても必要なときに限って使用するのが良い（これは決定性の操作と非決定性の操作を構文で区別するOzの立場で、純粋Prologはこれを区別しない）。

#### 他のモデルにおける論理型プログラミング
一章〜三章の直列宣言的モデル、それをそのまま並行的にした四章のモデルは既に述べたように論理型プログラミングが行える。第五章のポートを使用したメッセージ伝達並行モデルは非決定性を持つが、宣言的モデルに`WaitTwo`操作を加えて拡張することで表現できる（例えばAまたはBというメッセージが非決定的に来るというのは`Z = {WaitTwo A B}`でありその論理的意味は`z=a ∨ z=b`である）。六章〜八章の状態ありモデルは別で、これに論理的意味を簡単に与える方法はない。論理型プログラミングを行うためのモデルとしては、第十二章の制約ベース計算モデルがこの本の中で最も強力なものである。

## 関係プログラミングの有用な例
自然言語のようなあいまいな文法を解析するのに関係プログラミング（あるいは制約プログラミング）は好適である。lec/yaccなどのツールでは解析の難しい文法も解析することができる。この章では簡単な英文やS式の受理と木構造への変換、それを抽象化した文法インタプリタの例を見る。
