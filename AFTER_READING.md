# 読み終えてあるいは

二年前の夏くらいに読み始めて、ちょくちょくと読み進めていた「コンピュータ・プログラミングの概念・技法・モデル」という本をひと通り読み終えました。まあ読んだと言っても章末の練習問題は途中からやっていないので、おおよそ重要なことは一通り頭に入れた、という感じでしょうか。章によりますが大体２〜４回くらい読みました。

この本はちょうど自分がコンピュータ・サイエンスを学び始めたときから読み始めた本なので、過程をまとめることでこれまでどういうことを考えて何を学び、他にどういうことが足りていないか、というようなことを整理してみたいと思います。

## メモ
整理目的で書いた各章ごとのまとめ。

- [序文：プログラミングを学ぶにあたって](http://d.hatena.ne.jp/Altech/20110101/1293896398) - 2011-01-01
- [CTMCP 1章：プログラミング概念入門](http://d.hatena.ne.jp/Altech/20110104/1294156496) - 2011-01-04
- [CTMCP 2章：宣言的計算モデル](http://d.hatena.ne.jp/Altech/20110720/1311091857) - 2011-07-20
- [CTMCP 3章：宣言的プログラミング技法](http://d.hatena.ne.jp/Altech/20110804/1312404118) - 2011-08-04
  - [宣言的(declarative)であるとは](http://d.hatena.ne.jp/Altech/20110801/1312131972)
- [CTMCP 4章：宣言的並行性](http://d.hatena.ne.jp/Altech/20120318/1332006007) - 2012-03-18
  - [非決定性について少し](http://d.hatena.ne.jp/Altech/20120318/1332056930)
- [CTMCP 5章：メッセージ伝達並行性](http://d.hatena.ne.jp/Altech/20120322/1332364501) - 2012-03-22
- [CTMCP 6章：明示的状態](http://d.hatena.ne.jp/Altech/20120506/1336258094) - 2012-03-22
- [CTMCP 7章：オブジェクト指向プログラミング](http://d.hatena.ne.jp/Altech/20120515/1337090224) - 2012-05-15
- [CTMCP 8章：状態共有並行性](http://d.hatena.ne.jp/Altech/20121021/1350830918) - 2012-10-21
- [CTMCP 9章：関係プログラミング](http://d.hatena.ne.jp/Altech/20121021/1350832754) - 2012-10-21
- [CTMCP 11章：分散プログラミング](http://d.hatena.ne.jp/Altech/20121021/1350835101) -2012-10-21
- [CTMCP 12章：制約プログラミング](http://d.hatena.ne.jp/Altech/20121023/1350987658) - 2012-10-23

## きっかけと動機

大学一年の夏休みに「情報工学科に入ったわけだしコンピュータ・サイエンスのちゃんとした本を一冊読みたいなー」と思っていたところ、サークルのOBで当時なぜか部室に常駐していたdraftcodeさんからこの本を紹介してもらいました。ただこの当時はプログラミング経験やコンピュータ・サイエンス関係の基礎知識がほとんどなかったので、前提となる部分も一緒に読み解かなければならず、頁数としてはあまり捗りませんでした。

そういう状態でも無理矢理読み進めたのは、特定のプログラミング言語の「仕様」の上にプログラミングを覚えてしまえば、そういう先入観で考えるようになってしまう（そういう先入観は取り去るのが難しい）という予感があったからでした。ちなみに現時点では、これは半分正しくて半分間違っている、と思っています。そういう入り方をした場合でも多くの異なる言語に触れていけばおそらくだんだんと本質的な違いが整理されてくる。それに対してこの本はそういう本質を最初から扱ってそれに基いてプログラミングを教える本で、自分はそうしたいし、そうすることでより歪みなく本質的な理解をしたいと思ったのでした。

## どういう本？

この本は深いところに裏付けされて書いてある本なのでどのくらいのものが得られるかというのは読み込み次第で、自分も折に触れて関係する部分を読み返したいと思っているのですが、扱っていることは題の通りプログラミングです。プログラミングが次の３つに別れるとして、

1. 概念と技法
2. アルゴリズムとデータ構造
3. プログラム設計とソフトウェアエンジニアリング

このうちの1.を徹底的に扱い、2.と3.は入門程度に扱います。そして1.と3.は強い相互関係がある（と序文で言っています）。例えば「合成可能」あるいは「合成可能なコンポーネント」という概念と合成可能なコンポーネントを性能良く実現するための技法（e.g. メモ化）は、疎結合なプログラムを設計するにあたって必要な概念と技法です。自分の印象ですが、一般的にプログラミング言語にどういう機能があってどういう技法が可能というのを解説するプログラミング入門書は多くありますが、それと同時により大きな立場（つまり3.の観点）でどうすべきかということが説明されることはあまりないように思います。対してこの本は1.と3.を並行的に教えているので、3.についても比較的しっかりとした土台ができるように感じました。例えば、ソフトウェア・エンジニアリングの古典である「人月の神話」と言った本を読んでも（それほど開発経験はなくても）すんなりと納得できました。一方で、アルゴリズムとデータ構造については基本的なところは抑えてはいますが、まだまだ足りないと感じています。どうしよう。

## これから

やってみると誰でも普通にわかることですが、コンピューティング、情報システム、情報技術といった情報を対象としたエンジニアリングあるいはコンピュータを使ったエンジニアリングというのは別にプログラミングだけから構成されているわけではなく、その意味でこの本は一部に過ぎません。まずハードウェアがないとプログラミングはできませんし、プログラミングする対象についての知識があって的確に問題設定ができないとそもそもプログラミングしても意味が無い。あとはプラットフォーム（OS,ブラウザ, 言語処理系）とか環境（ライブラリ, コミュニティ, 人）とか解決手法とか自然言語とか。たぶんまだまだ見えてないものがあるはず。

そもそも自分がなにをしたいのかというのはまだ特に定まっていないのですが、日常を楽に（あるいは楽しく）するための手段としてコンピューティングは対象が広くて面白いと思いますし、何か思い立ったときに自分でできるようにしておきたいと思っています。ずいぶん抽象的な話になってしまったので具体的な話に戻すと、僕は、Ozから始めてRubyに至るまで抽象度の高いレイヤーにいることが多く、低レイヤーな部分を正確に理解していないなあと感じているので、とりあえず次はOSについて勉強してみようかなあとかなんとなく思ってます。
