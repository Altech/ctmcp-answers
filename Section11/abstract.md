# 第十一章：分散プログラミング

## 分散システムの分類
この章では、オープンな分散システムを扱う。以下のように、これはクラスタコンピューティングよりも一般的な分散システムである。
- メモリ共有マルチプロセッサ --分散--> 分散メモリマルチプロセッサ --部分的失敗--> 部分的失敗のある分散メモリマルチプロセッサ --オープン性--> オープン分散システム
  - 例えば高性能計算の大規模なものとしてスーパーコンピュータ上でのプログラミングがあるが、これは「部分的失敗のある分散メモリマルチプロセッサ」であり、オープン分散システムではない。

## 分散システム上でのプログラミング
- 問い：分散プログラミングは並列プログラミングの一種に過ぎず、従ってこれまでの並行プログラミングの技法がそのまま使える、か？
- 答え：次のような理由で、そう単純には行かない。
  - プロセスが別なのでアドレス空間も違う。データを変換して転送する必要がある。
  - ネットワークの性能は限られている。計算操作と比較して極端に遅い。
  - 資源によっては、特定のマシンでしか利用できない、などの偏り。
  - 部分的に機能しなくなる場合がある（ネットワークまたはマシンの故障）。
  - オープンな分散システムでは、セキュリティとネーミングの問題が発生する。

## ネットワーク透過性
- 理想的な場合、すなわち 1) ネットワークが高速で、2) 資源はどこでも使えて、3) 全てのコンピュータが故障無く起動・実行し、3) 全てのユーザーが互いに信頼できる、ような場合を仮定する。通常の並行プログラミングがどのように分散システムに分割されても、元の場合と同じように走ることを、システム側によって保証することができる。
- こういう単純さを保ちつつ、理想的でない場合にうまく対処したい。これはまだ解決をみない研究問題だが、その一角に触れる。次のようなことを考える必要がある。
  - Network Awareness :: プログラムの正しさを保ったまま、ネットワーク性能を調節するためには、ネットワークをどう使うかがある程度分かる必要がある（Awareness）。もっと言えば、ネットワーク操作は少数かつ予測可能である必要がある（？）
  - オープン性 :: 独立の計算を結合するためにどうするか。動的型付けであると比較的簡単にできる。
  - 局所化された資源を扱う :: 例えば何らかの仕事をして結果を返すサーバーがあったとして、クライアントはサーバーの資源（ファイルなど）を扱いたいかもしれない。そういった指定ができる必要がある。
  - 失敗の検出 :: アプリケーションプログラムから失敗を検出し、修復出来る必要がある。冗長性を使って失敗を隠蔽する抽象を構築することが考えられる。
  - この他にセキュリティ、ネーミング、資源管理、フォールトトレランス抽象といった問題があるが、ここでは触れない。

## ネットワーク透過であるということの具体例
例えば、プロセスAで`X=the_value(text: "It is a ...", author: "Tom")`が行われているとする。プロセスBでこの変数への参照Yがあれば、`{Browse Y}`で`the_value(text: "It is a ...", author: "Tom")`が確認できる。手続きや関数も値なので同様。もう一例、プロセスAで`declare X`として束縛されていない変数Xがあり、プロセスBでもこの変数への参照Y（すなわちXとYは意味的には同じものを参照している）を持つとする。プロセスAで`X=100`とすると、プロセスBにおいてYも100に束縛される。状態あり実体である、セル変数（手続き型言語などにおけるいわゆる「変数」）も同様に、その内容値を変更すればそれは全てのプロセスに及ぶ。

プロセス間に最初の参照を渡すための単純な機構として、チケットがある。あるプロセスにおいて`T={Connection.offer X}`とすることで変数Xに対する参照を表すチケットT（具体的には`oz-ticket://192.168.0.3:9000/h7413698#0`といった文字列）が生成される。何らかの方法で別プロセスがこのチケットを受け取り、`Y={Connection.take T}`とすれば、YはXと同じ言語実体を参照していることになる。

## 言語実体はどう分散されるか
言語実体はそれぞれホームプロセスを持つ。デフォルトでは、このホームプロセスは、その実体が生成されたプロセスである。数値、レコード、手続き、データフロー変数、セルなどそれぞれの言語実体に対して、どう分散されるかという分散プロトコルが単純な形で明確に定義されている。

例えば、大まかには、状態なし実体はその値が不変なので必要とした各プロセスにコピーが送られる（キャッシュされる）。状態あり実体は、いくつかのプロトコル（静止状態（元のプロセスに留まる）、モバイル状態（別プロセスに移動する）、無効化（最適化））がある。オブジェクトのデフォルトの分散プロトコルはモバイル状態である。モバイル状態においては、オブジェクト自体は各プロセスにキャッシュされており、状態を更新する權利（当然、一時に一つしかない）が必要に応じてプロセス間を移動する。

GCは、各プロセスの局所的GCと、遠隔参照を重み付きでカウントする分散GCが協調して働く。さらに、永久的とみなせる失敗を発見し、それに関連する実体をGCするタイムリース機構を持つ。

## 部分的失敗
最もよくある種類の失敗として、永久的なプロセスの失敗とネットワークの動作不能が挙げられる。Mozartシステムの失敗モデルはこの二種類を扱い、検出する。失敗モデルは、システム内で発生する様々な分散失敗を、それがどのように言語に反映されるかという失敗検出機構によって定義する。

プロセス失敗は永久的なものなので、`permFail`で表す。一般には、プロセス失敗はWAN（e.g. インターネット）の上で検出するすることはできず、LAN上でしか検出できない。一方、ネットワーク動作不能は、一時的なものと考える（`tempFail`）。修復されつつあると考える。これは時間切れ（time-out）とは違う。tempFailはアプリケーションにネットワークに問題があることを知らせるのであり、接続の終わりを示すのではない。これによって、アプリケーションは（例えば別のサーバーに繋ぐというような）対処をより早くできる。

設計について言うと、失敗の局限は、アプリケーション設計の最初から考えておくべきである。その際、失敗検出の同期／非同期と局限機構の間に基本的なトレード・オフがある。例えば、失敗検出が同期的であれば、局限機構は単純で済むが、性能は落ちる。これは楽観的な並行性制御と悲観的な並行性制御の間にあるトレード・オフと同様である。失敗の局限は、全ての失敗を内部的に処理する抽象を構築するのが一つの方法である。うまくいけば、完全に隠蔽できる。次善の方法として、（メッセージ伝達スタイルのように）プロセス間のインターフェースを狭くするものがある。対照して、分散システムの状態共有スタイルにおける処理処理は難しい。

## セキュリティ
安全であるということは全体的な性質である。システムのどこかの部分に弱点があればつけ込まれる。さらに言えば、絶対に安全であるということは無く、従ってセキュリティを破ろうとする体に割に合わないと思わせるくらいに、その労力を大きくすることしかできない。セキュリティの問題は分散システムの各層で現れる。アプリケーション、言語、言語実装、OS、ネットワーク、ハードウエア。

## 構築
分散アプリケーションの開発は、二段階で行う。まず最初にプロセスを分けずに、次にプロセスを分けて地理的・性能的な制約を加えて行う。
